package components

import (
	"fmt"
	"github.com/damongolding/immich-kiosk/config"
	"github.com/damongolding/immich-kiosk/immich"
	"github.com/damongolding/immich-kiosk/utils"
	"github.com/damongolding/immich-kiosk/views"
	"io"
	"slices"
	"strings"
	"time"
)

// Image is the main entry point for rendering images.
// It determines whether to use a single or split view layout based on the number of images,
// and renders the history form.
//
// Parameters:
//   - viewData: ViewData containing all necessary information for rendering the images.
templ Image(viewData views.ViewData) {
	if len(viewData.Images) < 2 {
		@layoutSingleView(viewData)
	} else {
		@layoutSplitView(viewData)
	}
	@renderHistory(viewData)
	if viewData.ShowMoreInfo {
		@renderMoreInfo(viewData)
	}
}

// layoutSingleView renders a single image layout.
//
// Parameters:
//   - viewData: ViewData containing all necessary information for rendering the image.
templ layoutSingleView(viewData views.ViewData) {
	@layoutView(viewData, true)
}

// layoutSplitView renders a split image layout for multiple images.
//
// Parameters:
//   - viewData: ViewData containing all necessary information for rendering the images.
templ layoutSplitView(viewData views.ViewData) {
	@layoutView(viewData, false)
}

// layoutView renders the layout for either a single image or multiple images.
// It applies the appropriate CSS classes and renders each image using renderSingleImage.
//
// Parameters:
//   - viewData: ViewData containing all necessary information for rendering the images.
//   - isSingle: A boolean indicating whether this is a single image layout.
templ layoutView(viewData views.ViewData, isSingle bool) {
	<div class={ "frame", templ.KV("frame-black-bg", !viewData.BackgroundBlur) }>
		if isSingle {
			@renderSingleImage(viewData, viewData.Images[0], 0)
		} else {
			for imageIndex, imageData := range viewData.Images {
				<div class={ fmt.Sprintf("frame--layout-%s", viewData.Layout) }>
					@renderSingleImage(viewData, imageData, imageIndex)
				</div>
			}
		}
	</div>
}

// renderSingleImage renders a single image with its background and metadata.
//
// Parameters:
//   - viewData: ViewData containing rendering settings.
//   - imageData: ImageData for the image to be rendered.
//   - imageIndex: The index of the image in the viewData.Images slice.
templ renderSingleImage(viewData views.ViewData, imageData views.ImageData, imageIndex int) {
	@renderImageBackground(viewData, imageData)
	@renderImage(viewData, imageData)
	if !viewData.DisableUi {
		@imageMetadata(viewData, imageIndex)
	}
}

// renderImageBackground renders a blurred background image if applicable.
//
// Parameters:
//   - viewData: ViewData containing background blur settings.
//   - imageData: ImageData containing the blur data for the image.
templ renderImageBackground(viewData views.ViewData, imageData views.ImageData) {
	if viewData.BackgroundBlur && !strings.EqualFold(viewData.ImageFit, "cover") && len(imageData.ImageBlurData) > 0 {
		<div class="frame--background">
			<img src={ imageData.ImageBlurData } alt="Blurred image background"/>
		</div>
	}
}

// renderImage renders an image with the specified effect and fit.
// It applies zoom effects if specified, otherwise renders the image with the default frame.
//
// Parameters:
//   - viewData: ViewData containing image effect and refresh settings.
//   - imageData: ImageData containing the image data and ImmichImage.
//
// The function uses frameWithZoom for zoom effects and frame for default rendering.
// It delegates to RenderImageWithCoverFit or renderImageFit based on the image effect.
templ renderImage(viewData views.ViewData, imageData views.ImageData) {
	switch viewData.ImageEffect {
		case "zoom", "smart-zoom":
			@frameWithZoom(viewData.Refresh, viewData.ImageEffect, imageData.ImmichImage) {
				@RenderImageWithCoverFit(imageData.ImageData, viewData.ImageFit)
			}
		default:
			@frame() {
				@renderImageFit(imageData.ImageData, viewData.ImageFit)
			}
	}
}

// renderImageFit selects and renders the appropriate image fit template based on the imageFit parameter.
//
// Parameters:
//   - imageData: A string containing the image data (typically a URL or base64-encoded image).
//   - imageFit: A string specifying the desired image fit style ("cover", "none", or any other value for "contain").
//
// The function uses a switch statement to determine which template to use:
//   - "cover": Uses RenderImageWithCoverFit
//   - "none": Uses RenderImageWithoutFit
//   - Any other value: Uses RenderImageWithContainFit (default behavior)
templ renderImageFit(imageData string, imageFit string) {
	switch imageFit {
		case "cover":
			@RenderImageWithCoverFit(imageData, imageFit)
		case "none":
			@RenderImageWithoutFit(imageData, imageFit)
		default:
			@RenderImageWithContainFit(imageData, imageFit)
	}
}

// RenderImageWithCoverFit renders an image with "cover" fit style.
//
// Parameters:
//   - ImageData: A string containing the image data (typically a URL or base64-encoded image).
//   - imageFit: A string specifying the image fit style (unused in this function).
templ RenderImageWithCoverFit(ImageData, imageFit string) {
	<img
		class="frame--image-fit-cover"
		src={ ImageData }
		alt="Main image"
	/>
}

// RenderImageWithoutFit renders an image without any specific fit style.
//
// Parameters:
//   - ImageData: A string containing the image data (typically a URL or base64-encoded image).
//   - imageFit: A string specifying the image fit style (unused in this function).
templ RenderImageWithoutFit(ImageData, imageFit string) {
	<img
		src={ ImageData }
		alt="Main image"
	/>
}

// RenderImageWithContainFit renders an image with "contain" fit style.
//
// Parameters:
//   - ImageData: A string containing the image data (typically a URL or base64-encoded image).
//   - imageFit: A string specifying the image fit style (unused in this function).
templ RenderImageWithContainFit(ImageData, imageFit string) {
	<img
		class="frame--image-fit-contain"
		src={ ImageData }
		alt="Main image"
	/>
}

func newHistoryEntry(images []views.ImageData) string {
	if len(images) == 0 {
		return ""
	}
	newImages := make([]string, len(images))
	for i, entry := range images {
		newImages[i] = entry.ImmichImage.ID
	}
	return strings.Join(newImages, ",")
}

// renderHistory renders a form containing the viewing history of images.
//
// Parameters:
//   - viewData: ViewData containing the history and current images.
templ renderHistory(viewData views.ViewData) {
	<form id="kiosk-history" hx-swap-oob="true">
		for _, historyEntry := range viewData.History {
			<input type="hidden" class="kiosk-history--entry" name="history" value={ historyEntry }/>
		}
		<input type="hidden" class="kiosk-history--entry" name="history" value={ newHistoryEntry(viewData.Images) }/>
	</form>
}

// ImageLocation generates a formatted string of the image location based on EXIF information.
// It combines the city, state, and country information if available.
func ImageLocation(info immich.ExifInfo, hideCountries []string) string {
	var parts []string

	if info.City != "" {
		parts = append(parts, info.City)
	}

	if info.State != "" {
		parts = append(parts, info.State)
	}

	if info.Country != "" && !slices.Contains(hideCountries, strings.ToLower(info.Country)) {
		if len(parts) > 0 {
			parts = append(parts, "<br class=\"responsive-break\"/>"+info.Country)
		} else {
			parts = append(parts, info.Country)
		}
	}

	return strings.Join(parts, ", ")
}

// ImageExif generates a formatted string of EXIF information for an image.
// It includes f-number, exposure time, focal length, and ISO if available.
func ImageExif(info immich.ExifInfo) string {
	var stats strings.Builder

	if info.FNumber != 0 {
		stats.WriteString(fmt.Sprintf("<span class=\"image--metadata--exif--fnumber\">&#402;</span>/%.1f", info.FNumber))
	}

	if info.ExposureTime != "" {
		if stats.Len() > 0 {
			stats.WriteString("<span class=\"image--metadata--exif--seperator\">&#124;</span>")
		}
		stats.WriteString(fmt.Sprintf("%s<small>s</small>", info.ExposureTime))
	}

	if info.FocalLength != 0 {
		if stats.Len() > 0 {
			stats.WriteString("<span class=\"image--metadata--exif--seperator\">&#124;</span>")
		}
		stats.WriteString(fmt.Sprintf("%vmm", info.FocalLength))
	}

	if info.Iso != 0 {
		if stats.Len() > 0 {
			stats.WriteString("<span class=\"image--metadata--exif--seperator\">&#124;</span>")
		}
		stats.WriteString(fmt.Sprintf("ISO %v", info.Iso))
	}

	return stats.String()
}

// ImageDateTime generates a formatted date and time string for an image based on the view data settings.
// It can display date, time, or both, in various formats.
func ImageDateTime(viewData views.ViewData, imageIndex int) string {
	var imageDate string

	imageTimeFormat := "15:04"
	if viewData.ImageTimeFormat == "12" {
		imageTimeFormat = time.Kitchen
	}

	imageDateFormat := utils.DateToLayout(viewData.ImageDateFormat)
	if imageDateFormat == "" {
		imageDateFormat = config.DefaultDateLayout
	}

	switch {
	case (viewData.ShowImageDate && viewData.ShowImageTime):
		imageDate = fmt.Sprintf("%s %s", viewData.Images[imageIndex].ImmichImage.LocalDateTime.Format(imageTimeFormat), viewData.Images[imageIndex].ImmichImage.LocalDateTime.Format(imageDateFormat))
	case viewData.ShowImageDate:
		imageDate = fmt.Sprintf("%s", viewData.Images[imageIndex].ImmichImage.LocalDateTime.Format(imageDateFormat))
	case viewData.ShowImageTime:
		imageDate = fmt.Sprintf("%s", viewData.Images[imageIndex].ImmichImage.LocalDateTime.Format(imageTimeFormat))
	}

	return imageDate
}

// imageMetadata renders the metadata for an image, including date, time, EXIF information, location, and ID.
// The display of each piece of information is controlled by the ViewData settings.
templ imageMetadata(viewData views.ViewData, imageIndex int) {
	<div class={ "image--metadata", fmt.Sprintf("image--metadata--theme-%s", viewData.Theme) }>
		if viewData.ShowImageDate || viewData.ShowImageTime {
			<div class="image--metadata--date">
				{ ImageDateTime(viewData, imageIndex) }
			</div>
		}
		if viewData.ShowImageDescription && viewData.Images[imageIndex].ImmichImage.ExifInfo.Description != "" {
			<div class="image--metadata--desciption">
				<small>
					{ viewData.Images[imageIndex].ImmichImage.ExifInfo.Description }
				</small>
			</div>
		}
		if viewData.ShowImageExif {
			<div class="image--metadata--exif">
				@templ.Raw(ImageExif(viewData.Images[imageIndex].ImmichImage.ExifInfo))
			</div>
		}
		if viewData.ShowImageLocation {
			<div class="image--metadata--location">
				@templ.Raw(ImageLocation(viewData.Images[imageIndex].ImmichImage.ExifInfo, viewData.HideCountries))
			</div>
		}
		if viewData.ShowImageID {
			<div class="image--metadata--id">
				{ viewData.Images[imageIndex].ImmichImage.ID }
			</div>
		}
	</div>
}

// animationDuration sets the CSS animation duration

css animationDuration(duration int) {
	animation-duration: { fmt.Sprintf("%ds", duration) };
}

// zoomInOrOut generates a random zoom in/out animation class name
func zoomInOrOut(zoomType string) string {
	return fmt.Sprintf("frame--image-%s-%s", zoomType, utils.RandomItem([]string{"in", "out"}))
}

// transformOrigin generates a CSS class for the transform-origin property.
//
// Parameters:
//   - value: A string representing the desired transform origin value.
//
// Returns:
//   - A CSS class for the transform-origin property.

css transformOrigin(value string) {
	transform-origin: { value };
	object-position: { value };
}

// smartZoom calculates the transform origin for an image based on detected faces.
// It returns a templ.CSSClass for the transform-origin CSS property.
//
// If no faces are detected, it returns a random corner as the transform origin.
// If faces are detected, it uses the center point of all faces as the transform origin.
//
// Parameters:
//   - image: An immich.ImmichAsset containing information about detected faces.
//
// Returns:
//   - templ.CSSClass: A CSS class for the transform-origin property.
func smartZoom(image immich.ImmichAsset) templ.CSSClass {
	if len(image.People) == 0 && len(image.UnassignedFaces) == 0 {
		return transformOrigin(fmt.Sprintf("%s%% %s%%", utils.RandomItem([]string{"30", "70"}), utils.RandomItem([]string{"30", "70"})))
	}

	x, y := image.FacesCenterPoint()

	if x == 0 || y == 0 {
		return transformOrigin(fmt.Sprintf("%s%% %s%%", utils.RandomItem([]string{"30", "70"}), utils.RandomItem([]string{"30", "70"})))
	}

	return transformOrigin(fmt.Sprintf("%f%% %f%%", x, y))
}

// frame is a template function that renders a basic frame for an image.
// It wraps the child content in a div with the class "frame--image".
templ frame() {
	<div class="frame--image">
		{ children... }
	</div>
}

// frameWithZoom is a template function that renders a frame with zoom effect for an image.
// It takes the refresh interval, image effect type, and the image asset as parameters.
// Depending on the image effect, it applies different CSS classes for zooming.
templ frameWithZoom(refresh int, imageEffect string, img immich.ImmichAsset) {
	switch imageEffect {
		case "smart-zoom":
			<div class={ "frame--image", "frame--image-zoom" , animationDuration(refresh), zoomInOrOut(imageEffect), smartZoom(img) }>
				{ children... }
			</div>
		default:
			<div class={ "frame--image", "frame--image-zoom" , animationDuration(refresh), zoomInOrOut(imageEffect) }>
				{ children... }
			</div>
	}
}

func immichImageUrl(baseUrl, imageID string) string {

	u, err := url.Parse(baseUrl)
	if err != nil {
		return "#"
	}

	apiUrl := url.URL{
		Scheme: u.Scheme,
		Host:   u.Host,
		Path:   path.Join("photos", imageID),
	}

	return apiUrl.String()
}

// webhookSignature generates a signature for webhook authentication.
// It combines the shared secret with the current Unix timestamp
// to create a time-based signature for securing webhook requests.
//
// Returns:
//   - A string containing the calculated signature
func webhookSignature() string {
	return utils.CalculateSignature(common.SharedSecret, strconv.FormatInt(time.Now().Unix(), 10))
}

func people(people []immich.Person) templ.Component {
	if len(people) == 0 {
		return templ.NopComponent
	}

	names := []string{}
	for _, person := range people {
		if person.Name != "" {
			names = append(names, templ.EscapeString(person.Name))
		}
	}

	if len(names) == 0 {
		return templ.NopComponent
	}

	return templ.ComponentFunc(func(ctx context.Context, w io.Writer) error {
		return templ.Raw(`
			<div>
				<div>
					<h3>People</h3>
				</div>
				<div>`+strings.Join(names, ", ")+`</div>
			</div>
		`).Render(ctx, w)
	})
}

templ renderMoreInfo(viewData views.ViewData) {
	<div id="more-info" hx-swap-oob="true">
		for _, img := range viewData.Images {
			<div class="more-info--image">
				<div class="more-info--image--data">
					<div>
						<div>
							<h3>
								if img.ImmichImage.ExifInfo.Make != "" {
									{ img.ImmichImage.ExifInfo.Make }
								} else {
									Unknown Make
								}
							</h3>
						</div>
						<div>
							if img.ImmichImage.ExifInfo.Model != "" {
								{ img.ImmichImage.ExifInfo.Model }
							} else {
								Unknown Model
							}
						</div>
					</div>
					<div>
						<div>
							<h3>
								{ img.ImmichImage.OriginalFileName }
							</h3>
						</div>
						<div>
							{ fmt.Sprint(img.ImmichImage.ExifInfo.ExifImageWidth) } x { fmt.Sprint(img.ImmichImage.ExifInfo.ExifImageHeight) } <span class="image--metadata--exif--seperator">&#124;</span> { human.Bytes(uint64(img.ImmichImage.ExifInfo.FileSizeInByte)) }
						</div>
					</div>
					@people(img.ImmichImage.People)
					<div class="more-info--button-group">
						if viewData.ShowMoreInfoImageLink {
							<a class="more-info--image-link" href={ templ.SafeURL(immichImageUrl(viewData.ImmichUrl, img.ImmichImage.ID)) } target="_blank">
								View image in Immich
							</a>
						}
						if len(viewData.Webhooks) != 0 {
							<button
								class="more-info--webhook"
								hx-post="/webhooks"
								hx-trigger="click throttle:2s"
								hx-include=".kiosk-history--entry"
								hx-headers={ fmt.Sprintf(`{"X-Timestamp": "%d", "X-Signature": "%s", "kiosk-webhook-event": "user.webhook.trigger.info_overlay"}`, time.Now().Unix(), webhookSignature()) }
								hx-swap="textContent"
							>
								Trigger webhook
							</button>
						}
					</div>
				</div>
				if viewData.ShowMoreInfoQrCode {
					<div class="more-info--image--qr-code">
						<img src={ utils.CreateQrCode(immichImageUrl(viewData.ImmichUrl, img.ImmichImage.ID)) }/>
					</div>
				}
			</div>
		}
	</div>
}
